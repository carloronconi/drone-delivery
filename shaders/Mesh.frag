#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 0) out vec4 outColor;layout(set = 0, binding = 0) uniform GlobalUniformBufferObject {	vec3 DlightDir;		// direction of the direct light	vec3 DlightColor;	// color of the direct light	vec3 AmbLightColor;	// ambient light	vec3 eyePos;		// position of the viewer	float usePointLight;} gubo;layout(set = 1, binding = 0) uniform UniformBufferObject {	float amb;	float gamma;	vec3 sColor; // if use this shader only for metallic objects can be removed (uses sColor = dColor)	mat4 mvpMat; // or keep it in case you decide that sColor gives a better looking result	mat4 mMat;	mat4 nMat;} ubo;layout(set = 1, binding = 1) uniform sampler2D tex;/*1) LIGHTING: DIRECT vs POINT (vs SPOT)DIRECT LIGHTvec3 lightDir = gubo.lightDir;vec3 lightColor = gubo.lightColor.rgb;POINT LIGHTvec3 lightDir = normalize(gubo.eyePos - fragPos);vec3 lightColor = gubo.lightColor.rgb * pow((g / length(gubo.eyePos - fragPos)), beta);SPOT LIGHTvec3 lightDir = normalize(gubo.eyePos - fragPos);vec3 arg = (normalize(gubo.eyePos - fragPos) * gubo.lightDir - cosout) / (cosin - cosout);vec3 lightColor = vec3(gubo.lightColor) * pow((g / length(gubo.eyePos - fragPos)), beta) * clamp(arg, cosout, cosin);2) BRDF: LAMBERT + PHONG/BLINN vs OREN-NAYAR vs COOK-TORRANCE3) AMBIENT: STANDARD vs HEMISPHERIC vs IMAGE-BASED*/const float beta = 2.0f;const float g = 1.5;const vec3 pointLightPos = vec3(-25.0, 25.0, -25.0);vec3 pointLightDir() {	return normalize(pointLightPos - fragPos);}vec3 pointLightColor() {	return gubo.DlightColor.rgb * pow((g / length(gubo.eyePos - fragPos)), beta);}void main() {	// DIRECT LIGHT	vec3 lightDir = (gubo.usePointLight == 1.0)? pointLightDir() : normalize(gubo.DlightDir); // AKA l	vec3 lightColor = (gubo.usePointLight == 1.0)? pointLightColor() : gubo.DlightColor.rgb;	vec3 albedo = texture(tex, fragUV).rgb;	// LAMBERT - BRDF diffuse reflection - diffuseBRDF(l, n, v, mD)	vec3 normal = normalize(fragNorm); // AKA n	vec3 diffuseColor = albedo; // AKA mD - surface diffuse color	vec3 diffuse = diffuseColor * clamp(dot(lightDir, normal), 0.0f, 1.0f);	// [unused] PHONG - BRDF specular reflection - specularBRDF(l, n, v, mS)	vec3 specularColor = diffuseColor; // AKA mS - should be vec3(1) for standard object or = diffuseColor for metallic objects	vec3 eyeDir = normalize(gubo.eyePos - fragPos); // AKA V, v, omegaR	// vec3 reflectDirection = - reflect(lightDir, normal); // direction of the reflected ray	// vec3 specular = specularColor * pow(clamp(dot(eyeDir, reflectDirection), 0.0f, 1.0f), ubo.gamma);	// BLINN - BRDF specular reflection (alternative: more expesive and more "reflective")	vec3 halfVector = normalize(lightDir + eyeDir);	vec3 specular = specularColor * pow(clamp(dot(normal, halfVector), 0.0f, 1.0f), ubo.gamma);	// HEMISPHERIC - AMBIENT LIGHTING	vec3 mAmbient = albedo * ubo.amb;	vec3 lAmbientUp = vec3(0.78f, 0.98f, 1.0f); // sky color - LIGHT BLUE - istead of using gubo.AmbLightColor (which is shared with other shader with												// oren-nayar that ends up looking bad if blue and is left white instead) use fixed blue color that												// only applies to metallic models using this shader	vec3 lAmbientDown = vec3(0.0f, 0.5f, 0.0f); // ground color - GREEN	vec3 upVector = vec3(0.0f, 1.0f, 0.0f);	float dotProd = dot(normal, upVector);	vec3 lAmbient = ((dotProd + 1.0f) / 2.0f) * lAmbientUp + ((1.0f - dotProd) / 2.0f) * lAmbientDown;	vec3 ambient = lAmbient * mAmbient;	// ADDING EVERYTHING	vec3 reflection = diffuse + specular;	outColor = vec4(clamp(reflection * lightColor + ambient,0.0,1.0), 1.0f);}